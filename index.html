<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>We-Leaf</title>
    <script src="https://cdn.tailwindcss.com/3.4.3"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <!-- Google tag (gtag.js) -->
  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-8HFKJ08L3L"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-8HFKJ08L3L");
  </script>
  <link rel="icon" href="images/scl_icon_small.png" type="image/png" />
  <body class="bg-black text-white min-h-screen flex flex-col">
    <header class="flex justify-end p-4">
      <div class="flex items-center justify-between w-full p-4">
        <!-- Logo Left -->
        <img src="images/senseable_white.png" alt="Logo 1" class="w-15 h-6" />

        <!-- Connection Line -->
        <div class="flex-1 mx-4 border-t border-gray-400"></div>

        <!-- Logo Right -->
        <img src="images/MIT_white.png" alt="Logo 2" class="w-12 h-6" />
      </div>
    </header>

    <main class="flex-1 flex flex-col items-center text-center px-4">
      <div id="scene-container" class="w-full h-[50vh]"></div>

      <p class="max-w-xl text-lg leading-relaxed italic">
        We-Leaf<br />
        The Global Tree of Senseable<br /><br />
      </p>
      <p class="max-w-xl text-xs leading-relaxed italic">
        From Rio to Dubai, Amsterdam to Boston, each Senseable City Lab around
        the world 3D printed leaves — a digital fabrication of local creativity
        and collaboration. These leaves, shaped in our “Global Labs,” travel
        alongside our researchers to Venice, where they are assembled into the
        Tree of Senseable: a living symbol of our shared curiosity, global
        connection, and the fusion of technology and nature. Each printed leaf
        carries with it the spirit of its city — together forming a collective
        canopy of ideas at the Venice Biennale.
      </p>
      <br />
      <a
        href="https://senseable.mit.edu/"
        target="_blank"
        rel="noopener noreferrer"
      >
        senseable.mit.edu</a
      >
      <br />
    </main>

    <script type="module">
      import * as THREE from "three";
      import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      let scene, camera, renderer, controls, loadedModel, modelGroup;

      const modelPath = "tree.obj";

      const rotationSpeed = 0.005;
      // --------------------------

      let container;

      init();
      animate();

      function init() {
        // Scene
        scene = new THREE.Scene();

        // 1. Get the container
        container = document.getElementById("scene-container");

        // Camera
        camera = new THREE.PerspectiveCamera(
          75,
          container.clientWidth / container.clientHeight,
          0.1,
          1000,
        );
        camera.position.set(0, -10, 40);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);

        container.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Soft white light
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Load Model
        loadModel();

        // Handle window resize
        window.addEventListener("resize", onWindowResize, false);
      }

      function loadModel() {
        const loader = new OBJLoader();

        modelGroup = new THREE.Group();
        modelGroup.position.set(0, -25, 0);
        scene.add(modelGroup);

        loader.load(
          // Resource URL
          modelPath,
          // onLoad callback
          function (object) {
            console.log("Model loaded successfully:", object);
            loadedModel = object; // Store the loaded model

            loadedModel.scale.set(0.1, 0.1, 0.1);

            // Correct orientation
            loadedModel.rotation.x = -Math.PI / 2; // Tilt it forward
            loadedModel.rotation.z = -Math.PI / 2; // Tilt it forward

            // Offset position to center the model
            loadedModel.position.set(-13, 0, -20); // Center the model

            loadedModel.traverse(function (child) {
              if (child.isMesh) {
                child.material = new THREE.MeshStandardMaterial({
                  color: 0x000000, // Black body

                  // We need this to prevent flickering (z-fighting)
                  polygonOffset: true,
                  polygonOffsetFactor: 1.0,
                  polygonOffsetUnits: 1.0,
                });

                const edges = new THREE.EdgesGeometry(child.geometry);
                const lineMaterial = new THREE.LineBasicMaterial({
                  color: 0xffffff, // White wireframe
                });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);

                // Add the wireframe as a child of the mesh
                child.add(wireframe);
              }
            });

            const vertexShader = `
                uniform float outlineThickness;
                void main() {
                    // Push the vertex out along its normal
                    vec3 newPosition = position + normal * outlineThickness;
                    
                    // Standard matrix transformation
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                }
            `;

            const fragmentShader = `
                uniform vec3 outlineColor;
                void main() {
                    gl_FragColor = vec4(outlineColor, 1.0);
                }
            `;

            const outlineMaterial = new THREE.ShaderMaterial({
              uniforms: {
                outlineThickness: { value: 2.0 },
                outlineColor: { value: new THREE.Color(0xffffff) }, // White
              },
              vertexShader: vertexShader,
              fragmentShader: fragmentShader,
              side: THREE.BackSide,
            });

            // Clone the model
            const outlineMesh = loadedModel.clone();

            // Apply the new shader material to the clone
            outlineMesh.traverse(function (child) {
              if (child.isMesh) {
                child.material = outlineMaterial;
              }
            });

            // Add the outline first (so it's drawn behind)
            modelGroup.add(outlineMesh);

            modelGroup.add(loadedModel);
          },
          // onProgress callback
          function (xhr) {
            console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
          },
          // onError callback
          function (error) {
            console.error("An error happened while loading the model:", error);
            alert("Error loading model. Check console (F12) for details.");
          },
        );
      }

      function onWindowResize() {
        if (container) {
          camera.aspect = container.clientWidth / container.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(container.clientWidth, container.clientHeight);
        }
      }

      function animate() {
        requestAnimationFrame(animate);

        // Check if the model has been loaded
        if (loadedModel) {
          modelGroup.rotation.y += rotationSpeed;
        }

        controls.update(); // Update controls (for damping)
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
